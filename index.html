<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½å•è¯è®°å¿†åŠ©æ‰‹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            position: relative;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .settings-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(30deg);
        }
        
        .main-content {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }
        
        .sidebar {
            flex: 1;
            min-width: 300px;
            background-color: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
        }
        
        .content-area {
            flex: 2;
            min-width: 300px;
            background-color: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
        }
        
        .section-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #2c3e50;
            border-bottom: 2px solid #f0f2f5;
            padding-bottom: 10px;
        }
        
        .mode-selector {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .mode-btn {
            padding: 15px;
            border-radius: 10px;
            background-color: #f8f9fa;
            border: 2px solid #e9ecef;
            text-align: left;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .mode-btn:hover {
            background-color: #e9ecef;
            border-color: #6a11cb;
        }
        
        .mode-btn.active {
            background-color: #e8f0fe;
            border-color: #6a11cb;
            color: #6a11cb;
        }
        
        .mode-icon {
            font-size: 1.2rem;
        }
        
        .progress-info {
            margin-top: 30px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 10px;
        }
        
        .progress-bar {
            height: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
            margin: 15px 0;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            border-radius: 5px;
            transition: width 0.5s;
        }
        
        .stats {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .stat-item {
            text-align: center;
            flex: 1;
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #6a11cb;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #6c757d;
            margin-top: 5px;
        }
        
        .flashcard {
            perspective: 1000px;
            width: 100%;
            height: 400px;
            margin: 0 auto 30px;
        }
        
        .flashcard-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        
        .flashcard.flipped .flashcard-inner {
            transform: rotateY(180deg);
        }
        
        .flashcard-front, .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }
        
        .flashcard-front {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: white;
        }
        
        .flashcard-back {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            transform: rotateY(180deg);
            text-align: left;
        }
        
        .word {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .phonetic {
            font-size: 1.5rem;
            opacity: 0.9;
            margin-bottom: 15px;
        }
        
        .pos {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 1rem;
            margin-bottom: 15px;
        }
        
        .meaning {
            font-size: 1.5rem;
            margin-bottom: 15px;
            line-height: 1.5;
        }
        
        .memory-aid {
            font-size: 1.2rem;
            opacity: 0.9;
            font-style: italic;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            line-height: 1.5;
        }
        
        .review-info {
            font-size: 1rem;
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            text-align: center;
        }
        
        .hint {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-top: 10px;
        }
        
        .card-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        .btn {
            display: inline-block;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            box-shadow: 0 4px 15px rgba(106, 17, 203, 0.3);
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(106, 17, 203, 0.4);
        }
        
        .btn:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.3);
        }
        
        .btn-secondary:hover {
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.4);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #4cd964 0%, #5ac8fa 100%);
            box-shadow: 0 4px 15px rgba(76, 217, 100, 0.3);
        }
        
        .btn-success:hover {
            box-shadow: 0 6px 20px rgba(76, 217, 100, 0.4);
        }
        
        .action-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .settings-panel {
            background-color: white;
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
            display: none;
        }
        
        .upload-area {
            border: 2px dashed #6a11cb;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .upload-area:hover {
            background-color: #f8f9ff;
            border-color: #2575fc;
        }
        
        .upload-icon {
            font-size: 3rem;
            color: #6a11cb;
            margin-bottom: 15px;
        }
        
        .word-list {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            padding: 10px;
        }
        
        .word-item {
            padding: 10px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .word-item:hover {
            background-color: #f8f9fa;
        }
        
        .word-item:last-child {
            border-bottom: none;
        }
        
        .word-text {
            font-weight: 500;
        }
        
        .word-meaning {
            color: #6c757d;
            font-size: 0.9rem;
            margin-top: 5px;
        }
        
        .word-review-info {
            font-size: 0.8rem;
            color: #6c757d;
            margin-top: 3px;
        }
        
        .status-mastered {
            color: #28a745;
        }
        
        .status-learning {
            color: #ffc107;
        }
        
        .status-new {
            color: #6c757d;
        }
        
        .status-review {
            color: #fd7e14;
        }
        
        .error-message {
            background-color: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: #6c757d;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .word {
                font-size: 2.5rem;
            }
            
            .meaning {
                font-size: 1.2rem;
            }
            
            .flashcard {
                height: 400px;
            }
            
            .action-buttons {
                flex-direction: column;
            }
            
            .action-buttons .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>æ™ºèƒ½å•è¯è®°å¿†åŠ©æ‰‹</h1>
            <p class="subtitle">åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿çš„æ™ºèƒ½å¤ä¹ ç³»ç»Ÿ</p>
            <button class="settings-btn" id="settingsBtn">âš™ï¸</button>
        </header>
        
        <div class="main-content">
            <div class="sidebar">
                <h2 class="section-title">å­¦ä¹ æ¨¡å¼</h2>
                <div class="mode-selector">
                    <button class="mode-btn active" data-mode="flashcard">
                        <span class="mode-icon">ğŸ”„</span>
                        <span>é—ªå¡å­¦ä¹ </span>
                    </button>
                    <button class="mode-btn" data-mode="review">
                        <span class="mode-icon">ğŸ“š</span>
                        <span>å¤ä¹ æ¨¡å¼</span>
                    </button>
                    <button class="mode-btn" data-mode="test">
                        <span class="mode-icon">âœï¸</span>
                        <span>å•è¯æµ‹è¯•</span>
                    </button>
                    <button class="mode-btn" data-mode="spelling">
                        <span class="mode-icon">ğŸ”¤</span>
                        <span>æ‹¼å†™ç»ƒä¹ </span>
                    </button>
                </div>
                
                <h2 class="section-title">å­¦ä¹ è¿›åº¦</h2>
                <div class="progress-info">
                    <p>å·²å­¦ä¹ : <span id="learnedCount">0</span> / <span id="totalCount">0</span> ä¸ªå•è¯</p>
                    <div class="progress-bar">
                        <div class="progress" id="progressBar" style="width: 0%"></div>
                    </div>
                    <p>æŒæ¡ç¨‹åº¦: <span id="masteryLevel">0%</span></p>
                    
                    <div class="stats">
                        <div class="stat-item">
                            <div class="stat-value" id="newCount">0</div>
                            <div class="stat-label">æ–°å•è¯</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="reviewCount">0</div>
                            <div class="stat-label">å¾…å¤ä¹ </div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="masteredCount">0</div>
                            <div class="stat-label">å·²æŒæ¡</div>
                        </div>
                    </div>
                </div>
                
                <div class="settings-panel" id="settingsPanel">
                    <h2 class="section-title">è®¾ç½®</h2>
                    
                    <div id="fileStatus" class="error-message" style="display: none;">
                        æ— æ³•åŠ è½½c.txtæ–‡ä»¶ï¼Œè¯·æ‰‹åŠ¨ä¸Šä¼ å•è¯æ–‡ä»¶
                    </div>
                    
                    <div class="upload-area" id="uploadArea">
                        <div class="upload-icon">ğŸ“š</div>
                        <p>ç‚¹å‡»æˆ–æ‹–æ‹½æ‚¨çš„txtå•è¯æ–‡ä»¶åˆ°è¿™é‡Œ</p>
                        <p class="hint">æ”¯æŒæ ¼å¼ï¼šå•è¯ éŸ³æ ‡ | è¯æ€§. é‡Šä¹‰ è®°å¿†æ–¹æ³•</p>
                        <input type="file" id="fileInput" accept=".txt" style="display: none;">
                    </div>
                    
                    <h2 class="section-title">å•è¯åˆ—è¡¨</h2>
                    <div class="word-list" id="wordList">
                        <p style="text-align: center; color: #6c757d;">æ­£åœ¨åŠ è½½å•è¯...</p>
                    </div>
                </div>
            </div>
            
            <div class="content-area">
                <h2 class="section-title" id="modeTitle">é—ªå¡å­¦ä¹ </h2>
                
                <div class="flashcard" id="flashcard">
                    <div class="flashcard-inner">
                        <div class="flashcard-front">
                            <div class="word" id="wordFront">æ­£åœ¨åŠ è½½å•è¯...</div>
                            <div class="review-info" id="reviewInfoFront" style="display: none;"></div>
                            <p class="hint">ç‚¹å‡»å¡ç‰‡æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯</p>
                        </div>
                        <div class="flashcard-back">
                            <div class="word" id="wordBack">-</div>
                            <div class="phonetic" id="wordPhonetic"></div>
                            <div class="pos" id="wordPos"></div>
                            <div class="meaning" id="wordMeaning">-</div>
                            <div class="memory-aid" id="wordMemory"></div>
                            <div class="review-info" id="reviewInfoBack" style="display: none;"></div>
                        </div>
                    </div>
                </div>
                
                <div class="card-controls">
                    <button class="btn" id="prevBtn" disabled>â—€ ä¸Šä¸€ä¸ª</button>
                    <button class="btn" id="flipBtn">ğŸ”„ ç¿»è½¬å¡ç‰‡</button>
                    <button class="btn" id="nextBtn" disabled>ä¸‹ä¸€ä¸ª â–¶</button>
                </div>
                
                <div class="action-buttons">
                    <button class="btn btn-success" id="markKnownBtn" style="display: none;">è®¤è¯†</button>
                    <button class="btn btn-secondary" id="markUnknownBtn" style="display: none;">ä¸è®¤è¯†</button>
                    <button class="btn btn-secondary" id="markMasteredBtn" disabled>æ ‡è®°ä¸ºå·²æŒæ¡</button>
                    <button class="btn" id="shuffleBtn" disabled>éšæœºæ’åº</button>
                    <button class="btn" id="exportBtn" disabled>å¯¼å‡ºå•è¯è¡¨</button>
                </div>
            </div>
        </div>
        
        <footer>
            <p>å•è¯è®°å¿†åŠ©æ‰‹ &copy; 2025 - åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿</p>
        </footer>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let wordList = [];
        let currentIndex = 0;
        let currentMode = 'flashcard';
        let wordProgress = JSON.parse(localStorage.getItem('wordProgress')) || {};
        let flippedWords = new Set(); // è®°å½•å·²ç»ç¿»è¿‡é¢çš„å•è¯
        
        // è‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿å¤ä¹ é—´éš”ï¼ˆå°æ—¶ï¼‰
        const reviewIntervals = [1, 24, 72, 168, 336, 720]; // 1å°æ—¶, 1å¤©, 3å¤©, 7å¤©, 14å¤©, 30å¤©
        
        // DOMå…ƒç´ 
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsPanel = document.getElementById('settingsPanel');
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const fileStatus = document.getElementById('fileStatus');
        const flashcard = document.getElementById('flashcard');
        const wordFront = document.getElementById('wordFront');
        const wordBack = document.getElementById('wordBack');
        const wordPhonetic = document.getElementById('wordPhonetic');
        const wordPos = document.getElementById('wordPos');
        const wordMeaning = document.getElementById('wordMeaning');
        const wordMemory = document.getElementById('wordMemory');
        const reviewInfoFront = document.getElementById('reviewInfoFront');
        const reviewInfoBack = document.getElementById('reviewInfoBack');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const flipBtn = document.getElementById('flipBtn');
        const markKnownBtn = document.getElementById('markKnownBtn');
        const markUnknownBtn = document.getElementById('markUnknownBtn');
        const markMasteredBtn = document.getElementById('markMasteredBtn');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const exportBtn = document.getElementById('exportBtn');
        const learnedCount = document.getElementById('learnedCount');
        const totalCount = document.getElementById('totalCount');
        const reviewCount = document.getElementById('reviewCount');
        const newCount = document.getElementById('newCount');
        const masteredCount = document.getElementById('masteredCount');
        const progressBar = document.getElementById('progressBar');
        const masteryLevel = document.getElementById('masteryLevel');
        const wordListContainer = document.getElementById('wordList');
        const modeTitle = document.getElementById('modeTitle');
        const modeButtons = document.querySelectorAll('.mode-btn');
        
        // é¡µé¢åŠ è½½æ—¶å°è¯•åŠ è½½c.txtæ–‡ä»¶
        window.addEventListener('DOMContentLoaded', () => {
            loadDefaultFile();
        });
        
        // å°è¯•åŠ è½½é»˜è®¤æ–‡ä»¶c.txt
        async function loadDefaultFile() {
            try {
                const response = await fetch('c.txt');
                if (!response.ok) {
                    throw new Error('æ–‡ä»¶åŠ è½½å¤±è´¥');
                }
                const content = await response.text();
                processWordContent(content);
                fileStatus.style.display = 'none';
            } catch (error) {
                console.error('æ— æ³•åŠ è½½c.txtæ–‡ä»¶:', error);
                fileStatus.style.display = 'block';
                wordFront.textContent = 'æ— æ³•åŠ è½½c.txtæ–‡ä»¶';
                wordListContainer.innerHTML = '<p style="text-align: center; color: #6c757d;">è¯·æ‰‹åŠ¨ä¸Šä¼ å•è¯æ–‡ä»¶</p>';
            }
        }
        
        // äº‹ä»¶ç›‘å¬
        settingsBtn.addEventListener('click', () => {
            settingsPanel.style.display = settingsPanel.style.display === 'block' ? 'none' : 'block';
        });
        
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.style.backgroundColor = '#f0f4ff';
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.style.backgroundColor = '';
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.style.backgroundColor = '';
            const file = e.dataTransfer.files[0];
            if (file && file.type === 'text/plain') {
                loadWordFile(file);
            } else {
                alert('è¯·ä¸Šä¼ txtæ ¼å¼çš„æ–‡ä»¶');
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loadWordFile(file);
            }
        });
        
        flashcard.addEventListener('click', () => {
            const wasFlipped = flashcard.classList.contains('flipped');
            flashcard.classList.toggle('flipped');
            
            // å¦‚æœæ˜¯ä»æ­£é¢ç¿»åˆ°èƒŒé¢ï¼Œæ ‡è®°ä¸ºå·²ç¿»é¢
            if (!wasFlipped && flashcard.classList.contains('flipped')) {
                markWordAsFlipped();
            }
        });
        
        flipBtn.addEventListener('click', () => {
            const wasFlipped = flashcard.classList.contains('flipped');
            flashcard.classList.toggle('flipped');
            
            // å¦‚æœæ˜¯ä»æ­£é¢ç¿»åˆ°èƒŒé¢ï¼Œæ ‡è®°ä¸ºå·²ç¿»é¢
            if (!wasFlipped && flashcard.classList.contains('flipped')) {
                markWordAsFlipped();
            }
        });
        
        prevBtn.addEventListener('click', showPreviousWord);
        nextBtn.addEventListener('click', showNextWord);
        
        markKnownBtn.addEventListener('click', markAsKnown);
        markUnknownBtn.addEventListener('click', markAsUnknown);
        markMasteredBtn.addEventListener('click', markAsMastered);
        shuffleBtn.addEventListener('click', shuffleWords);
        exportBtn.addEventListener('click', exportWordList);
        
        modeButtons.forEach(button => {
            button.addEventListener('click', () => {
                modeButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                currentMode = button.dataset.mode;
                modeTitle.textContent = getModeTitle(currentMode);
                updateUIForMode();
                updateWordList();
                
                if (currentMode === 'test' || currentMode === 'spelling') {
                    alert(`åˆ‡æ¢åˆ°${button.textContent}æ¨¡å¼ - æ­¤åŠŸèƒ½æ­£åœ¨å¼€å‘ä¸­`);
                }
            });
        });
        
        // è·å–æ¨¡å¼æ ‡é¢˜
        function getModeTitle(mode) {
            const titles = {
                'flashcard': 'é—ªå¡å­¦ä¹ ',
                'review': 'å¤ä¹ æ¨¡å¼',
                'test': 'å•è¯æµ‹è¯•',
                'spelling': 'æ‹¼å†™ç»ƒä¹ '
            };
            return titles[mode] || 'å­¦ä¹ æ¨¡å¼';
        }
        
        // æ ¹æ®æ¨¡å¼æ›´æ–°UI
        function updateUIForMode() {
            if (currentMode === 'review') {
                markKnownBtn.style.display = 'inline-block';
                markUnknownBtn.style.display = 'inline-block';
                markMasteredBtn.style.display = 'none';
                reviewInfoFront.style.display = 'block';
                reviewInfoBack.style.display = 'block';
            } else {
                markKnownBtn.style.display = 'none';
                markUnknownBtn.style.display = 'none';
                markMasteredBtn.style.display = 'inline-block';
                reviewInfoFront.style.display = 'none';
                reviewInfoBack.style.display = 'none';
            }
        }
        
        // åŠ è½½å•è¯æ–‡ä»¶
        function loadWordFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                processWordContent(content);
                fileStatus.style.display = 'none';
            };
            reader.readAsText(file);
        }
        
        // å¤„ç†å•è¯å†…å®¹ - é€‚é…æ–°æ ¼å¼
        function processWordContent(content) {
            const lines = content.split('\n');
            wordList = [];
            
            lines.forEach(line => {
                line = line.trim();
                if (line) {
                    // è§£ææ ¼å¼ï¼šå•è¯ éŸ³æ ‡ | è¯æ€§. é‡Šä¹‰ è®°å¿†æ–¹æ³•
                    const wordData = parseWordLine(line);
                    if (wordData) {
                        wordList.push(wordData);
                    }
                }
            });
            
            if (wordList.length > 0) {
                currentIndex = 0;
                updateFlashcard();
                updateProgress();
                updateWordList();
                
                // å¯ç”¨æŒ‰é’®
                markMasteredBtn.disabled = false;
                shuffleBtn.disabled = false;
                exportBtn.disabled = false;
                
                alert(`æˆåŠŸåŠ è½½ ${wordList.length} ä¸ªå•è¯`);
            } else {
                alert('æœªæ‰¾åˆ°æœ‰æ•ˆçš„å•è¯æ•°æ®ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼');
            }
        }
        
        // è§£æå•è¯è¡Œæ•°æ®
        function parseWordLine(line) {
            // æ ¼å¼ï¼šå•è¯ éŸ³æ ‡ | è¯æ€§. é‡Šä¹‰ è®°å¿†æ–¹æ³•
            const parts = line.split('\t');
            if (parts.length < 2) return null;
            
            const word = parts[0].trim();
            const rest = parts[1].trim();
            
            // åˆ†ç¦»éŸ³æ ‡å’Œè¯æ€§é‡Šä¹‰éƒ¨åˆ†
            const phoneticAndPos = rest.split(' | ');
            if (phoneticAndPos.length < 2) return null;
            
            const phonetic = phoneticAndPos[0].trim();
            const posAndMeaning = phoneticAndPos[1].trim();
            
            // åˆ†ç¦»è¯æ€§å’Œé‡Šä¹‰
            const posMatch = posAndMeaning.match(/^(\w+\.)\s+(.+)$/);
            if (!posMatch) return null;
            
            const pos = posMatch[1];
            const meaningAndMemory = posMatch[2];
            
            // åˆ†ç¦»é‡Šä¹‰å’Œè®°å¿†æ–¹æ³•
            let meaning = meaningAndMemory;
            let memory = '';
            
            // å°è¯•åˆ†ç¦»è®°å¿†æ–¹æ³•ï¼ˆå¦‚æœæœ‰åˆ¶è¡¨ç¬¦åˆ†éš”ï¼‰
            if (parts.length > 2) {
                memory = parts[2].trim();
            } else {
                // å¦‚æœæ²¡æœ‰åˆ¶è¡¨ç¬¦åˆ†éš”ï¼Œå°è¯•åœ¨é‡Šä¹‰ä¸­æŸ¥æ‰¾è®°å¿†æ–¹æ³•
                const memoryIndex = meaningAndMemory.indexOf('\t');
                if (memoryIndex !== -1) {
                    meaning = meaningAndMemory.substring(0, memoryIndex).trim();
                    memory = meaningAndMemory.substring(memoryIndex + 1).trim();
                }
            }
            
            return {
                word: word,
                phonetic: phonetic,
                pos: pos,
                meaning: meaning,
                memory: memory
            };
        }
        
        // æ ‡è®°å•è¯ä¸ºå·²ç¿»é¢ï¼ˆå³è¿›å…¥å¤ä¹ ç³»ç»Ÿï¼‰
        function markWordAsFlipped() {
            if (wordList.length === 0) return;
            
            const currentWord = wordList[currentIndex].word;
            const progress = wordProgress[currentWord] || { stage: 0, nextReview: 0, lastReviewed: 0 };
            
            // åªæœ‰å½“å•è¯å°šæœªè¿›å…¥å¤ä¹ ç³»ç»Ÿæ—¶ï¼Œæ‰å°†å…¶æ ‡è®°ä¸ºä¸ç†Ÿæ‚‰
            if (progress.stage === 0) {
                const now = Date.now();
                progress.stage = 1;
                progress.nextReview = now + reviewIntervals[0] * 60 * 60 * 1000; // 1å°æ—¶å
                progress.lastReviewed = now;
                
                wordProgress[currentWord] = progress;
                localStorage.setItem('wordProgress', JSON.stringify(wordProgress));
                
                // è®°å½•è¿™ä¸ªå•è¯å·²ç»è¢«ç¿»è¿‡é¢
                flippedWords.add(currentWord);
                
                // æ›´æ–°è¿›åº¦å’Œå•è¯åˆ—è¡¨
                updateProgress();
                updateWordList();
                
                console.log(`å•è¯ "${currentWord}" å·²æ ‡è®°ä¸ºä¸ç†Ÿæ‚‰ï¼Œè¿›å…¥å¤ä¹ ç³»ç»Ÿ`);
            }
        }
        
        // æ›´æ–°é—ªå¡å†…å®¹
        function updateFlashcard() {
            if (wordList.length === 0) {
                wordFront.textContent = 'è¯·ä¸Šä¼ å•è¯æ–‡ä»¶';
                wordBack.textContent = '-';
                wordPhonetic.textContent = '';
                wordPos.textContent = '';
                wordMeaning.textContent = '-';
                wordMemory.textContent = '';
                reviewInfoFront.textContent = '';
                reviewInfoBack.textContent = '';
                return;
            }
            
            const currentWord = wordList[currentIndex];
            wordFront.textContent = currentWord.word;
            wordBack.textContent = currentWord.word;
            wordPhonetic.textContent = currentWord.phonetic;
            wordPos.textContent = currentWord.pos;
            wordMeaning.textContent = currentWord.meaning;
            wordMemory.textContent = currentWord.memory;
            
            // å¦‚æœæ²¡æœ‰è®°å¿†æ–¹æ³•ï¼Œéšè—è¯¥éƒ¨åˆ†
            if (!currentWord.memory) {
                wordMemory.style.display = 'none';
            } else {
                wordMemory.style.display = 'block';
            }
            
            // æ›´æ–°å¤ä¹ ä¿¡æ¯
            const word = currentWord.word;
            const progress = wordProgress[word] || { stage: 0, nextReview: 0, lastReviewed: 0 };
            
            if (currentMode === 'review') {
                const now = Date.now();
                const nextReviewTime = new Date(progress.nextReview);
                const lastReviewedTime = new Date(progress.lastReviewed);
                
                reviewInfoFront.textContent = `å¤ä¹ é˜¶æ®µ: ${progress.stage}/6 | ä¸‹æ¬¡å¤ä¹ : ${formatDate(nextReviewTime)}`;
                reviewInfoBack.textContent = `ä¸Šæ¬¡å¤ä¹ : ${formatDate(lastReviewedTime)} | ä¸‹æ¬¡å¤ä¹ : ${formatDate(nextReviewTime)}`;
            }
            
            // é‡ç½®å¡ç‰‡çŠ¶æ€
            flashcard.classList.remove('flipped');
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            prevBtn.disabled = currentIndex === 0;
            nextBtn.disabled = currentIndex === wordList.length - 1;
            
            // æ›´æ–°å·²æŒæ¡çŠ¶æ€
            const isMastered = progress.stage === 6;
            markMasteredBtn.textContent = isMastered ? 'å–æ¶ˆæŒæ¡æ ‡è®°' : 'æ ‡è®°ä¸ºå·²æŒæ¡';
            markMasteredBtn.classList.toggle('btn-secondary', !isMastered);
        }
        
        // æ ¼å¼åŒ–æ—¥æœŸ
        function formatDate(date) {
            if (date.getTime() === 0) return 'ä»æœªå¤ä¹ ';
            
            const now = new Date();
            const diffMs = date - now;
            const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));
            
            if (diffDays < 0) {
                return 'å·²è¿‡æœŸ';
            } else if (diffDays === 0) {
                return 'ä»Šå¤©';
            } else if (diffDays === 1) {
                return 'æ˜å¤©';
            } else {
                return `${diffDays}å¤©å`;
            }
        }
        
        // æ˜¾ç¤ºä¸Šä¸€ä¸ªå•è¯
        function showPreviousWord() {
            if (currentIndex > 0) {
                currentIndex--;
                updateFlashcard();
            }
        }
        
        // æ˜¾ç¤ºä¸‹ä¸€ä¸ªå•è¯
        function showNextWord() {
            if (currentIndex < wordList.length - 1) {
                currentIndex++;
                updateFlashcard();
            }
        }
        
        // æ ‡è®°ä¸ºè®¤è¯†ï¼ˆå¤ä¹ æ¨¡å¼ï¼‰
        function markAsKnown() {
            if (wordList.length === 0) return;
            
            const currentWord = wordList[currentIndex].word;
            const progress = wordProgress[currentWord] || { stage: 0, nextReview: 0, lastReviewed: 0 };
            
            // æ›´æ–°å¤ä¹ è¿›åº¦
            const now = Date.now();
            progress.lastReviewed = now;
            
            if (progress.stage < reviewIntervals.length) {
                progress.stage++;
                progress.nextReview = now + reviewIntervals[progress.stage - 1] * 60 * 60 * 1000;
            } else {
                progress.stage = 6; // å·²æŒæ¡
                progress.nextReview = Number.MAX_SAFE_INTEGER;
            }
            
            wordProgress[currentWord] = progress;
            localStorage.setItem('wordProgress', JSON.stringify(wordProgress));
            
            // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå•è¯
            showNextReviewWord();
        }
        
        // æ ‡è®°ä¸ºä¸è®¤è¯†ï¼ˆå¤ä¹ æ¨¡å¼ï¼‰
        function markAsUnknown() {
            if (wordList.length === 0) return;
            
            const currentWord = wordList[currentIndex].word;
            const progress = wordProgress[currentWord] || { stage: 0, nextReview: 0, lastReviewed: 0 };
            
            // é‡ç½®å¤ä¹ è¿›åº¦
            const now = Date.now();
            progress.lastReviewed = now;
            progress.stage = 1;
            progress.nextReview = now + reviewIntervals[0] * 60 * 60 * 1000;
            
            wordProgress[currentWord] = progress;
            localStorage.setItem('wordProgress', JSON.stringify(wordProgress));
            
            // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå•è¯
            showNextReviewWord();
        }
        
        // æ˜¾ç¤ºä¸‹ä¸€ä¸ªéœ€è¦å¤ä¹ çš„å•è¯
        function showNextReviewWord() {
            const now = Date.now();
            let nextIndex = -1;
            
            // ä»å½“å‰ä½ç½®å‘åæŸ¥æ‰¾éœ€è¦å¤ä¹ çš„å•è¯
            for (let i = currentIndex + 1; i < wordList.length; i++) {
                const word = wordList[i].word;
                const progress = wordProgress[word] || { stage: 0, nextReview: 0 };
                
                if (progress.stage > 0 && progress.stage < 6 && progress.nextReview <= now) {
                    nextIndex = i;
                    break;
                }
            }
            
            // å¦‚æœåé¢æ²¡æœ‰ï¼Œä»å¼€å¤´æŸ¥æ‰¾
            if (nextIndex === -1) {
                for (let i = 0; i < currentIndex; i++) {
                    const word = wordList[i].word;
                    const progress = wordProgress[word] || { stage: 0, nextReview: 0 };
                    
                    if (progress.stage > 0 && progress.stage < 6 && progress.nextReview <= now) {
                        nextIndex = i;
                        break;
                    }
                }
            }
            
            if (nextIndex !== -1) {
                currentIndex = nextIndex;
                updateFlashcard();
            } else {
                alert('æ­å–œï¼æ‰€æœ‰éœ€è¦å¤ä¹ çš„å•è¯éƒ½å·²ç»å®Œæˆï¼');
                // åˆ‡æ¢åˆ°é—ªå¡å­¦ä¹ æ¨¡å¼
                modeButtons[0].click();
            }
        }
        
        // æ ‡è®°ä¸ºå·²æŒæ¡
        function markAsMastered() {
            if (wordList.length === 0) return;
            
            const currentWord = wordList[currentIndex].word;
            const progress = wordProgress[currentWord] || { stage: 0, nextReview: 0, lastReviewed: 0 };
            
            if (progress.stage === 6) {
                // å–æ¶ˆæŒæ¡æ ‡è®°
                progress.stage = 0;
                progress.nextReview = 0;
            } else {
                // æ ‡è®°ä¸ºå·²æŒæ¡
                progress.stage = 6;
                progress.nextReview = Number.MAX_SAFE_INTEGER;
                progress.lastReviewed = Date.now();
            }
            
            wordProgress[currentWord] = progress;
            localStorage.setItem('wordProgress', JSON.stringify(wordProgress));
            
            updateFlashcard();
            updateProgress();
            updateWordList();
        }
        
        // éšæœºæ’åºå•è¯
        function shuffleWords() {
            if (wordList.length === 0) return;
            
            // Fisher-Yates æ´—ç‰Œç®—æ³•
            for (let i = wordList.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [wordList[i], wordList[j]] = [wordList[j], wordList[i]];
            }
            
            currentIndex = 0;
            updateFlashcard();
            updateWordList();
        }
        
        // å¯¼å‡ºå•è¯åˆ—è¡¨
        function exportWordList() {
            if (wordList.length === 0) return;
            
            let content = "å•è¯\téŸ³æ ‡\tè¯æ€§\té‡Šä¹‰\tè®°å¿†æ–¹æ³•\tæŒæ¡çŠ¶æ€\tä¸‹æ¬¡å¤ä¹ \n";
            wordList.forEach(wordObj => {
                const progress = wordProgress[wordObj.word] || { stage: 0, nextReview: 0 };
                const isMastered = progress.stage === 6;
                const nextReview = progress.nextReview > 0 ? new Date(progress.nextReview).toLocaleDateString() : 'æ— éœ€å¤ä¹ ';
                
                content += `${wordObj.word}\t${wordObj.phonetic}\t${wordObj.pos}\t${wordObj.meaning}\t${wordObj.memory}\t${isMastered ? 'å·²æŒæ¡' : 'å­¦ä¹ ä¸­'}\t${nextReview}\n`;
            });
            
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'æˆ‘çš„å•è¯è¡¨.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // æ›´æ–°å­¦ä¹ è¿›åº¦
        function updateProgress() {
            const total = wordList.length;
            let learned = 0;
            let needReview = 0;
            let newWords = 0;
            const now = Date.now();
            
            wordList.forEach(wordObj => {
                const progress = wordProgress[wordObj.word] || { stage: 0, nextReview: 0 };
                if (progress.stage === 6) {
                    learned++;
                } else if (progress.stage > 0 && progress.stage < 6 && progress.nextReview <= now) {
                    needReview++;
                } else if (progress.stage === 0) {
                    newWords++;
                }
            });
            
            learnedCount.textContent = learned;
            totalCount.textContent = total;
            reviewCount.textContent = needReview;
            newCount.textContent = newWords;
            masteredCount.textContent = learned;
            
            const progress = total > 0 ? (learned / total) * 100 : 0;
            progressBar.style.width = `${progress}%`;
            masteryLevel.textContent = `${Math.round(progress)}%`;
        }
        
        // æ›´æ–°å•è¯åˆ—è¡¨æ˜¾ç¤º
        function updateWordList() {
            wordListContainer.innerHTML = '';
            
            if (wordList.length === 0) {
                wordListContainer.innerHTML = '<p style="text-align: center; color: #6c757d;">æš‚æ— å•è¯</p>';
                return;
            }
            
            const now = Date.now();
            let displayWords = [];
            
            if (currentMode === 'review') {
                // å¤ä¹ æ¨¡å¼ï¼šåªæ˜¾ç¤ºéœ€è¦å¤ä¹ çš„å•è¯
                displayWords = wordList.filter(wordObj => {
                    const progress = wordProgress[wordObj.word] || { stage: 0, nextReview: 0 };
                    return progress.stage > 0 && progress.stage < 6 && progress.nextReview <= now;
                });
            } else {
                // å…¶ä»–æ¨¡å¼ï¼šæ˜¾ç¤ºæ‰€æœ‰å•è¯
                displayWords = wordList;
            }
            
            if (displayWords.length === 0 && currentMode === 'review') {
                wordListContainer.innerHTML = '<p style="text-align: center; color: #6c757d;">æš‚æ— éœ€è¦å¤ä¹ çš„å•è¯</p>';
                return;
            }
            
            displayWords.forEach((wordObj, index) => {
                const wordItem = document.createElement('div');
                wordItem.className = 'word-item';
                
                const progress = wordProgress[wordObj.word] || { stage: 0, nextReview: 0 };
                const isMastered = progress.stage === 6;
                const isCurrent = wordList.indexOf(wordObj) === currentIndex;
                const needsReview = progress.stage > 0 && progress.stage < 6 && progress.nextReview <= now;
                const isNew = progress.stage === 0;
                
                let statusClass = 'status-new';
                if (isMastered) {
                    statusClass = 'status-mastered';
                } else if (needsReview) {
                    statusClass = 'status-review';
                } else if (progress.stage > 0) {
                    statusClass = 'status-learning';
                }
                
                wordItem.innerHTML = `
                    <div>
                        <span class="word-text ${isCurrent ? statusClass + ' current' : statusClass}">
                            ${isCurrent ? 'â–¶ ' : ''}${wordObj.word}
                        </span>
                        <div class="word-meaning">${wordObj.meaning.substring(0, 30)}${wordObj.meaning.length > 30 ? '...' : ''}</div>
                        <div class="word-review-info">å¤ä¹ é˜¶æ®µ: ${progress.stage}/6 | ä¸‹æ¬¡å¤ä¹ : ${formatDate(new Date(progress.nextReview))}</div>
                    </div>
                    <span>${isMastered ? 'âœ“' : (needsReview ? '!' : (isNew ? 'ğŸ†•' : ''))}</span>
                `;
                
                wordItem.addEventListener('click', () => {
                    currentIndex = wordList.indexOf(wordObj);
                    updateFlashcard();
                });
                
                wordListContainer.appendChild(wordItem);
            });
        }
        
        // åˆå§‹åŒ–
        updateUIForMode();
        updateFlashcard();
        updateProgress();
        updateWordList();
    </script>
</body>
</html>
